<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sophia LeBlanc">

<title>W11 Taskset: Emotional Stroop</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="w11_taskset_files/libs/clipboard/clipboard.min.js"></script>
<script src="w11_taskset_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="w11_taskset_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="w11_taskset_files/libs/quarto-html/popper.min.js"></script>
<script src="w11_taskset_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="w11_taskset_files/libs/quarto-html/anchor.min.js"></script>
<link href="w11_taskset_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="w11_taskset_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="w11_taskset_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="w11_taskset_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="w11_taskset_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">W11 Taskset: Emotional Stroop</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Sophia LeBlanc </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="workflow-summary--" class="level4">
<h4 class="anchored" data-anchor-id="workflow-summary--">Workflow Summary ——————————-</h4>
<p>In this <code>.qmd</code>, my workflow begins with calling in necessary packages and loading applicable functions. <code>process_participant</code> sources the other functions within itself, so it is the only function I explicitly call here. I find my data files and subsequently apply <code>process_participant</code> to them.</p>
<p>Within <code>process_participant</code>, I extract subject IDs, read in <code>.csv</code>s, implement column correction checks, source my other functions, and apply those functions before combining select outputs in a new, clean dataframe.</p>
<ul>
<li><p>The <code>compute_rt_if_missing</code> function calculates RTs utilizing onset and response timepoints if the RT is missing.</p></li>
<li><p><code>summarize_behavior</code> converts accuracy data to logical, helps filter to correct trials, and calculates related accuracy and rt means.</p></li>
<li><p><code>score_questionnaire</code> converts the json string into interpretable, numeric data. This function also involves reverse scoring some items to allow us to properly analyse the data.</p></li>
</ul>
<p>Overall, this <code>.qmd</code> utilizes the modularized workflow to scale up the functions to cover several files of participant data and combine participant rows into a table.</p>
</section>
<section id="handling-missing-data--" class="level4">
<h4 class="anchored" data-anchor-id="handling-missing-data--">Handling Missing Data ——————————-</h4>
<p>In <code>compute_rt_if_missing</code>, I salvaged participant data (that may have otherwise been excluded &amp; lowered the sample size): If the data had response and start/end timepoints, I could calculate response time if it was missing. True missing trials (NA for rt, response, and correct) were excluded to prevent issues with calculating RT and determining if the trial was accurate, thus improving reproducibility and data quality.</p>
</section>
<section id="concept-check--" class="level4">
<h4 class="anchored" data-anchor-id="concept-check--">Concept Check ——————————-</h4>
<ul>
<li>Q1: What does <code>source("scripts/score_questionnaire.R")</code> enable in your workflow?
<ul>
<li><code>source()</code> helps us literally “source” R scripts into our Quarto file. We used our script files as toolkits to hold functions; now, we are loading functions through source into the QMD file. The functions from our scripts are then available for our use in Quarto. In this case, the score_questionnaire function becomes available for use.</li>
</ul></li>
<li>Q2: Why is modularizing your code into multiple scripts considered a best practice?
<ul>
<li>Modularizing helps make our code more clear, comprehensible, and easier to use for reproducibility’s sake. By splitting into different scripts and documents, we can be more intentional with our code and identify specific purposes/functions per script. There’s also the benefit of a cleaner, more organized workspace. We can also reuse the code/logic in our components across different data and multiple files, granting us scalability. A Quarto report, which may dynamically interact with/source different R scripts, can bring our components together in an understandable, reproducible workflow. This report almost works like a narrative that can be retold among researchers.</li>
</ul></li>
<li>Q3: What information does <code>traceback()</code> provide after an error?
<ul>
<li><code>traceback()</code> provides information about where the error occurred. Specifically, the command reports the previous call sequence leading up to the error, so you don’t have to do the searching yourself. You can more easily identify the place/call and related steps that led to the error.</li>
</ul></li>
<li>Q4: When you read multiple <code>.csv</code> files into R, how can using <code>str()</code> or <code>names()</code> before combining them help you prevent or debug errors later in your workflow?
<ul>
<li><code>str()</code> or <code>names()</code> are very helpful commands to help catch errors early, which prevent errors and further complications later on (i.e., when trying to perform data manipulation or analysis). These are both ways to “inspect” the data and ensure it loads as expected. <code>str()</code> checks the data’s structure (e.g., column types, # of obs and variables, data types, preview of data). <code>names()</code> provides the column/variable names. So, overall, using these checks can determine if files we’re seeking to combine have the same number of columns, the same column names, and/or the same data types per column to ensure successful data merging. We can make necessary changes (e.g., renaming columns, converting data types) before moving forward.</li>
</ul></li>
<li>Q5: How can you check whether your function actually loaded correctly into your environment, and why is this step important before calling it in later code?
<ul>
<li>One strategy is to clear the environment and start fresh to see if the code can run independently (determine if the script is dependent on ‘leftover’ objects). The code itself may need to be changed to be relative. Commands are helpful tools: <code>ls()</code> or <code>objects()</code> can list variables/objects in the environment, <code>environment()</code> can check where functions are running, or you can call the function and use <code>print()</code> to ensure the input/output values are as intended, confirming the function’s efficacy. This step is extremely important to preserve reproducibility. We should make sure the function is operating correctly and independently before calling it for later use.</li>
</ul></li>
</ul>
</section>
<section id="flitering-computing-rts-on-correct-trials" class="level4">
<h4 class="anchored" data-anchor-id="flitering-computing-rts-on-correct-trials">Flitering &amp; Computing RTs on Correct Trials</h4>
<ul>
<li>Why do we filter RTs to 300–900 ms and compute RTs on correct trials only?
<ul>
<li>We filter RTs to a specific speed range to exclude outlier values, and we compute correct trials to ensure we are working with RT values representing accurate Emotional Stroop responses. We want to investigate emotional inference which may be shown in differences in response time across correct trials (i.e., was there a delay in getting to the correct answer?); including inaccurate trials may introduce other confounds that don’t represent biases.</li>
</ul></li>
</ul>
</section>
<section id="code-begins--" class="level4">
<h4 class="anchored" data-anchor-id="code-begins--">CODE BEGINS ——————————-</h4>
</section>
<section id="call-in-packages--" class="level4">
<h4 class="anchored" data-anchor-id="call-in-packages--">Call in packages ——————————-</h4>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(jsonlite)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="load-functions--" class="level4">
<h4 class="anchored" data-anchor-id="load-functions--">Load functions ————————————————————-</h4>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scripts"</span>,<span class="st">"process_participant.R"</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="find-files--" class="level4">
<h4 class="anchored" data-anchor-id="find-files--">Find files ————————————————————-</h4>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Prefer a pattern to avoid accidentally pulling other CSVs</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>file_list <span class="ot">&lt;-</span> <span class="fu">list.files</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"data"</span>,<span class="st">"raw"</span>), <span class="at">pattern =</span> <span class="st">"^est-experiment-.*</span><span class="sc">\\</span><span class="st">.csv$"</span>, <span class="at">full.names =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="apply-our-participant-processor" class="level4">
<h4 class="anchored" data-anchor-id="apply-our-participant-processor">Apply our participant processor —————————————</h4>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>participant_rows <span class="ot">&lt;-</span> <span class="fu">lapply</span>(file_list, process_participant)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in FUN(X[[i]], ...): Column 'trial_type' found in
est-experiment-2025-11-05-10-11-45 -- renaming to 'trialType'.</code></pre>
</div>
</div>
</section>
<section id="combine-into-one-study-level-data-frame" class="level4">
<h4 class="anchored" data-anchor-id="combine-into-one-study-level-data-frame">Combine into one study-level data frame ——————————–</h4>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>study_level <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind, participant_rows)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(study_level)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                           subject_id mean_accuracy mean_rt_correct esq_sum
1  est-experiment-2025-11-05-09-04-45     0.7666667        567.2045      20
2  est-experiment-2025-11-05-09-07-45     0.7818182        583.4250      22
3  est-experiment-2025-11-05-09-12-45     0.7192982        571.3659      17
4  est-experiment-2025-11-05-09-17-45     0.7457627        591.3571      18
5  est-experiment-2025-11-05-09-19-45     0.7586207        561.5349      17
6  est-experiment-2025-11-05-09-23-45     0.6842105        563.7895      13
7  est-experiment-2025-11-05-09-29-45     0.6785714        546.2778      17
8  est-experiment-2025-11-05-09-31-45     0.7118644        516.7750      18
9  est-experiment-2025-11-05-09-36-45     0.7272727        564.0500      18
10 est-experiment-2025-11-05-09-41-45     0.5892857        530.1613      23
11 est-experiment-2025-11-05-09-43-45     0.5849057        561.0323      21
12 est-experiment-2025-11-05-09-49-45     0.7068966        566.1250      24
13 est-experiment-2025-11-05-09-51-45     0.7321429        544.9000      23
14 est-experiment-2025-11-05-09-55-45     0.6440678        569.7838      20
15 est-experiment-2025-11-05-09-59-45     0.7241379        580.8537      21
16 est-experiment-2025-11-05-10-04-45     0.6964286        578.4211      24
17 est-experiment-2025-11-05-10-08-45     0.7272727        555.2000      17
18 est-experiment-2025-11-05-10-11-45     0.7241379        558.4390      16
19 est-experiment-2025-11-05-10-15-45     0.7192982        535.4750      21
20 est-experiment-2025-11-05-10-19-45     0.6491228        591.3514      16</code></pre>
</div>
</div>
<p>The <code>mean</code> RT across the study is 561.88 ms, and the <code>mean</code> accuracy is 0.7.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>