library("ggplot2")
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("build_participant_wide.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("build_participant_wide.R"))
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/calc_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
participant_wide <- build_participant_wide()
questionnaire_df
??library
if (!require("pacman")) {
install.packages("pacman"); library(pacman, quietly = TRUE)
}
p_load("ggplot2", "here", "jsonlite")
library(readr)
sub_001_P2P1_CONGfirst <- read_csv("data/raw/sub-001_P2P1_CONGfirst.csv")
View(sub_001_P2P1_CONGfirst)
test <- "sub-001_P2P1_CONGfirst.csv"
test <- read.csv("sub-001_P2P1_CONGfirst.csv")
getwd()
setwd("/Users/sophialeblanc/Desktop/psy1903/web/project2/data/raw")
test <- read.csv("sub-001_P2P1_CONGfirst.csv")
#### Read participant CSV ----------------------------------------------------
df <- read.csv(
here::here("data", "raw", file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
import_and_process <- function(test) {
#### Read participant CSV ----------------------------------------------------
df <- read.csv(
here::here("data", "raw", test),
check.names = FALSE,
stringsAsFactors = FALSE
)
required_cols <- c("trialType", "block", "rt", "response", "trial_index",
"time_elapsed", "word", "expectedCategory",
"expectedCategoryAsDisplayed", "leftCategory", "rightCategory",
"correct", "question_order")
import_and_process("sub-001_P2P1_CONGfirst.csv")
#### Read participant CSV ----------------------------------------------------
df <- read.csv(
here::here("data", "raw", file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
#### Read participant CSV ----------------------------------------------------
df <- read.csv(
here::here("data", "raw", file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
import_and_process <- function(file_name) {
#### Read participant CSV ----------------------------------------------------
df <- read.csv(
here::here("data", "raw", file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
## If you see an error "cannot open the connection", it usually means that R cannot find something where it's looking. Check your paths, files, and file_name. Remember where file_name comes from.
#### Check expected columns ----------------------------
## If this fails, write code using if(), %in%, and names() to rename any
## mismatched column names reproducibly every time you render from the raw data
required_cols <- c("trialType", "block", "rt", "response", "trial_index",
"time_elapsed", "word", "expectedCategory",
"expectedCategoryAsDisplayed", "leftCategory", "rightCategory",
"correct", "question_order")
# Don't refactor to ifelse() - later when doing the AI comparison, you can ask why
if (!all(required_cols %in% names(df))) {
stop(
paste(
"Input data frame missing required columns in",
sub("\\.csv$", "", basename(file_name)),
"\nExpected:",
paste(required_cols, collapse = ", "),
"\nFound:",
paste(names(df), collapse = ", ")
)
)
}
#### Extract subject_id from file name ---------------------------------------
id <- regmatches(file_name, regexpr("sub-[0-9]{3}", file_name))
subject_id <- ifelse(length(id) == 1, id, NA_character_)
rm(id)
if (is.na(subject_id)) {
warning("Filename does not contain a valid 'sub-###' pattern: ", file_name)
}
#### Subset questionnaire vs. task -------------------------------------------
task_df <- df[df$trialType == "iat", , drop = FALSE]
questionnaire_df <- df[df$trialType == "questionnaire", , drop = FALSE]
if (nrow(questionnaire_df) != 1) {
warning("Empty 'questionnaire_df' where data expected. In future steps, 'score_questionnaire' will not run correctly.")
}
#### Calculate Behavior & Questionnaire Scores -------------------------------
behavior <- summarize_behavior(task_df)
anxiety_score <- score_questionnaire(questionnaire_df$response)
#### Save participant summary ------------------------------------------------
## Ensure output directory is created
dir.create(
here::here("data", "cleaned", "participants"),
recursive = TRUE,
showWarnings = FALSE
)
## Combine into a single-row participant summary
df_clean <- data.frame(
subject_id = subject_id,
anxiety_score = anxiety_score,
congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
## Save summary CSV to cleaned/participants
write.csv(
df_clean,
here::here("data", "cleaned", "participants", paste0(subject_id, "_cleaned.csv")),
row.names = FALSE
)
#### Return output -----------------------------------------------------------
stopifnot(nrow(df_clean) == 1)  # one row per participant
return(df_clean)
}
import_and_process("sub-001_P2P1_CONGfirst.csv")
file_name <- "sub-001_P2P1_CONGfirst.csv"
> file_name <- "sub-001_P2P1_CONGfirst.csv"
file_name <- "sub-001_P2P1_CONGfirst.csv"
df <- read.csv(
here::here("data", "raw", file_name),
check.names = FALSE,
stringsAsFactors = FALSE
)
View(df)
required_cols <- c("trialType", "block", "rt", "response", "trial_index",
"time_elapsed", "word", "expectedCategory",
"expectedCategoryAsDisplayed", "leftCategory", "rightCategory",
"correct", "question_order")
if (!all(required_cols %in% names(df))) {
stop(
paste(
"Input data frame missing required columns in",
sub("\\.csv$", "", basename(file_name)),
"\nExpected:",
paste(required_cols, collapse = ", "),
"\nFound:",
paste(names(df), collapse = ", ")
)
)
}
id <- regmatches(file_name, regexpr("sub-[0-9]{3}", file_name))
subject_id <- ifelse(length(id) == 1, id, NA_character_)
rm(id)
if (is.na(subject_id)) {
warning("Filename does not contain a valid 'sub-###' pattern: ", file_name)
}
task_df <- df[df$trialType == "iat", , drop = FALSE]
View(task_df)
questionnaire_df <- df[df$trialType == "questionnaire", , drop = FALSE]
View(df)
questionnaire_df <- df[df$trialType == "Questionnaire", , drop = FALSE]
View(questionnaire_df)
View(questionnaire_df)
if (nrow(questionnaire_df) != 1) {
warning("Empty 'questionnaire_df' where data expected. In future steps, 'score_questionnaire' will not run correctly.")
}
ensure_dir <- function(path) if (!dir.exists(path)) dir.create(path, recursive = TRUE, showWarnings = FALSE)
ensure_dir(file.path(here::here("data","raw")))
ensure_dir(file.path(here::here("data","cleaned")))
ensure_dir(file.path(here::here("outputs","tables")))
ensure_dir(file.path(here::here("outputs","plots")))
if (!require("pacman")) {
install.packages("pacman"); library(pacman, quietly = TRUE)
}
p_load("ggplot2", "here", "jsonlite")
source(here::here("scripts/calculate_iat_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
behavior <- summarize_behavior(task_df)
anxiety_score <- score_questionnaire(questionnaire_df$response)
View(questionnaire_df)
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
data <- task_df
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
str(data)
normalize_logical <- function(x) {
if (is.logical(x)) return(x)
if (is.numeric(x)) return(x == 1)
if (is.character(x)) return(toupper(x) == "TRUE")
as.logical(x)
}
if (!is.logical(data$correct)) {
data$correct <- normalize_logical(data$correct)
}
behavior <- summarize_behavior(task_df)
behavior <- summarize_behavior(task_df)
source(here::here("scripts/calculate_iat_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
behavior <- summarize_behavior(task_df)
if (!is.numeric(data$rt)) {
data$rt <- as.numeric(data$rt)
}
normalize_logical <- function(x) {
if (is.logical(x)) return(x)
if (is.numeric(x)) return(x == 1)
if (is.character(x)) return(toupper(x) == "TRUE")
as.logical(x)
}
if (!is.logical(data$correct)) {
data$correct <- normalize_logical(data$correct)
}
valid_data_rt <- data[data[ , 3] >= 300 & data[ , 3] <= 900 & data[ , 12] == TRUE, ]
valid_data_acc <- data[data[ , 3] >= 300 & data[ , 3] <= 900, ]
valid_data_rt$rt_centered <- NA_real_
for (i in 1:nrow(valid_data_rt)) {
valid_data_rt$rt_centered[i] <- valid_data_rt$rt[i] - mean(valid_data_rt$rt, na.rm = TRUE)
}
test_data_rt <- valid_data_rt[grepl(" or ", valid_data_rt$expectedCategory), , drop = FALSE]
test_data_acc <- valid_data_acc[grepl(" or ", valid_data_acc$expectedCategory), , drop = FALSE]
desired_order <- c(
"nature or serenity or school or anxiety",
"nature or anxiety or school or serenity"
)
grp_rt <- factor(
test_data_rt$expectedCategoryAsDisplayed,
levels = desired_order
)
grp_acc <- factor(
test_data_acc$expectedCategoryAsDisplayed,
levels = desired_order
)
means <- tapply(test_data_rt$rt, grp_rt, FUN = mean)
accuracy <- tapply(test_data_acc$correct, grp_acc, FUN = mean)
d_score  <- calculate_iat_dscore(test_data_rt)
View(behavior)
desired_order <- c(
"nature or serenity or school or anxiety", # congruent
"nature or anxiety or school and serenity"  # incongruent
)
grp <- factor(
test_df$expectedCategoryAsDisplayed,
levels = desired_order
)
anxiety_score <- score_questionnaire(questionnaire_df$response)
responses <- jsonlite::fromJSON(as.character(json_string))
json_string <- questionnaire_df$response; reverse <- c(2, 5); scale_min <- 1L; scale_max <- 5L
responses <- jsonlite::fromJSON(as.character(json_string))
View(responses)
responses[sapply(response, is.null)] <- NA
responses[sapply(responses, is.null)] <- NA
responses <- jsonlite::fromJSON(as.character(json_string))
View(responses)
responses[sapply(response, is.null)] <- NA
responses[sapply(responses, is.null)] <- NA
anxiety_score <- score_questionnaire(questionnaire_df$response)
source(here::here("scripts/calculate_iat_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
anxiety_score <- score_questionnaire(questionnaire_df$response)
View(responses)
if (length(reverse) > 0) {
responses[reverse] <- (scale_max + scale_min) - responses[reverse]
}
json_string <- questionnaire_df$response
reverse <- c(2, 5)
scale_min <- 1L
scale_max <- 5L
if (is.null(json_string) || is.na(json_string) || !nzchar(json_string)) {
warning("JSON string is missing or empty. Returning NA.")
return(NA_real_)
}
responses <- jsonlite::fromJSON(as.character(json_string))
responses[sapply(responses, is.null)] <- NA
responses <- jsonlite::fromJSON(as.character(json_string))
responses[sapply(responses, is.null)] <- NA
responses <- unlist(responses)
responses <- as.numeric(responses)
if (length(reverse) > 0) {
if (any(reverse < 1 | reverse > length(responses))) {
stop("One or more 'reverse' item indices are out of range for this questionnaire response.")
}
}
if (length(reverse) > 0) {
responses[reverse] <- (scale_max + scale_min) - responses[reverse]
}
mean_score <- mean(responses, na.rm = TRUE)
return(mean_score)
mean_score <- mean(responses, na.rm = TRUE)
return(mean_score)
anxiety_score <- score_questionnaire(questionnaire_df$response)
df_clean <- data.frame(
subject_id = subject_id,
anxiety_score = anxiety_score,
congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
d_score  <- calculate_iat_dscore(test_data_rt)
test_df <- test_data_rt
desired_order <- c(
"nature or serenity or school or anxiety", # congruent
"nature or anxiety or school and serenity"  # incongruent
)
grp <- factor(
test_df$expectedCategoryAsDisplayed,
levels = desired_order
)
cong_rt   <- test_df$rt[grp == desired_order[1]]
incong_rt <- test_df$rt[grp == desired_order[2]]
cong_rt   <- cong_rt[!is.na(cong_rt)]
incong_rt <- incong_rt[!is.na(incong_rt)]
View(test_df)
if (length(cong_rt) < 5L || length(incong_rt) < 5L) {
warning("Not enough usable trials: inspect length(cong_rt) and length(incong_rt) to ensure both are ≥ 5.")
return(NA_real_)
}
unique(test_df$expectedCategoryAsDisplayed) == desired_order
unique(test_df$expectedCategoryAsDisplayed)
desired_order
desired_order <- c(
"nature or serenity or school or anxiety", # congruent
"nature or anxiety or school or serenity"  # incongruent
)
grp <- factor(
test_df$expectedCategoryAsDisplayed,
levels = desired_order
)
cong_rt   <- test_df$rt[grp == desired_order[1]]
incong_rt <- test_df$rt[grp == desired_order[2]]
cong_rt   <- cong_rt[!is.na(cong_rt)]
incong_rt <- incong_rt[!is.na(incong_rt)]
if (length(cong_rt) < 5L || length(incong_rt) < 5L) {
warning("Not enough usable trials: inspect length(cong_rt) and length(incong_rt) to ensure both are ≥ 5.")
return(NA_real_)
}
pooled_sd <- sd(test_df$rt, na.rm = TRUE)
if (is.na(pooled_sd) || pooled_sd == 0) {
return(NA_real_)
}
d_score <- (mean(incong_rt, na.rm = TRUE) - mean(cong_rt, na.rm = TRUE)) / pooled_sd
d_score
anxiety_score <- score_questionnaire(questionnaire_df$response)
source(here::here("scripts/calculate_iat_dscore.R"))
source(here::here("scripts/score_questionnaire.R"))
source(here::here("scripts/summarize_behavior.R"))
source(here::here("scripts/import_and_process.R"))
source(here::here("scripts/build_participant_wide.R"))
anxiety_score <- score_questionnaire(questionnaire_df$response)
View(behavior)
View(questionnaire_df)
df_clean <- data.frame(
subject_id = subject_id,
anxiety_score = anxiety_score,
congruent_mean = behavior["congruent_mean"],
incongruent_mean = behavior["incongruent_mean"],
congruent_accuracy = behavior["congruent_accuracy"],
incongruent_accuracy = behavior["incongruent_accuracy"],
d_score = behavior["d_score"],
row.names = NULL
)
